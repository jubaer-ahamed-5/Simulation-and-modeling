# -*- coding: utf-8 -*-
"""ssq.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1apBSAqMqYNimQhk80JGgTAHB7Rp2HYlw
"""

import numpy as np
import operator

avg_fifo = 0.0
avg_lifo = 0.0
avg_sjf = 0.0


def fifo(xp, yp):
    #np.random.seed(0)

    class Simulation:
        def __init__(self):
            self.interarrivals = []
            self.interarrivals = xp.tolist()

            self.service_times = []
            self.service_times = yp.tolist()
            print(self.interarrivals)
            print(self.service_times)
            self.clock = 0.0

            self.next_arrival = self.interarrivals.pop(0)
            self.next_departure = float('inf')

            self.num_in_queue = 0
            self.times_of_arrivalqueue = []  # store times of arrivals who are waiting in the queue
            self.service_times_in_queue = []  # store service times of waiting customers in the queue

            self.total_delay = 0.0
            self.num_of_delays = 0.0
            self.area_under_q = 0.0
            self.area_under_b = 0.0
            self.number_of_customers_in_q = 0.0

            self.server_status = 0  # 0 for IDLE , 1 for BUSY
            self.last_event_time = 0.0  # we will need to store last event clock time

        def start(self):
            while self.num_of_delays <= 5:
                self.timing()

        def timing(self):
            global avg_fifo
            self.clock = min(self.next_arrival, self.next_departure)  # First set clock to minimum time of next event
            self.update_register()
            if self.next_arrival <= self.next_departure:
                self.arrival()
                print("Arrival at Clock:" + str(self.clock))

            else:
                self.departure()
                print("Departure at " + str(self.clock))

            print("Server Status:" + str(self.server_status))
            print("Times of arrivals in Queue: " + str(self.times_of_arrivalqueue))
            print("Service times in Queue: " + str(self.service_times_in_queue))
            print("Number of Delays: " + str(self.num_of_delays))
            print("Total Delay:" + str(self.total_delay))
            print("Next Arrival Time: " + str(self.next_arrival))
            print("Next Departure Time: " + str(self.next_departure))
            print("Expected average Delay:" + str(self.total_delay / 6))
            avg_fifo = self.total_delay / 6
            self.number_of_customers_in_q = len(self.service_times_in_queue) + self.number_of_customers_in_q
            print("Average number of customers in queue:" + str(self.number_of_customers_in_q / 6))

            print(" ")

        def arrival(self):
            # Schedule next arrival , new_arrival = previous_arrival + inter_arrival time of next customer
            self.next_arrival += self.interarrivals.pop(0)

            if self.server_status == 0:  # server is idle
                self.server_status = 1  # make server BUSY
                delay = 0.0  # so delay is zero
                self.total_delay += delay
                self.num_of_delays += 1  # increase the number of customers delayed

                # schedule next departure, pop the first element of service_times list to get service time of this customer
                self.next_departure = self.clock + self.service_times.pop(0)

            else:  # Server is BUSY
                # increase queue length, this customer will have to wait in the queue
                self.num_in_queue += 1

                # store the arrival time and service time of this customer in seperate lists
                self.times_of_arrivalqueue.append(self.clock)
                self.service_times_in_queue.append(self.service_times.pop(0))

        def departure(self):
            # check number of customers in the queue
            if self.num_in_queue == 0:  # if no customer in the queue
                # make server IDLE
                self.server_status = 0
                # schedule next departure= infinity
                self.next_departure = float('infinity')

            else:
                # if queue not empty, pop one customer, decrease queue length
                self.num_in_queue -= 1
                self.num_of_delays += 1
                # AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
                # For SJF, finf the index of minimum service time from  service_times_in_queue list.
                # Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.

                arrival = self.times_of_arrivalqueue.pop(0)

                delay = self.clock - arrival
                self.total_delay += delay
                self.next_departure = self.clock + self.service_times_in_queue.pop(0)

        def update_register(self):
            time_differnce = self.clock - self.last_event_time
            self.area_under_q += self.num_in_queue * time_differnce
            self.area_under_b += self.server_status * time_differnce
            self.last_event_time = self.clock

    s = Simulation()
    s.start()


def lifo(xp, yp):
    import numpy as np
    np.random.seed(0)

    class Simulation:


        def __init__(self):
            self.interarrivals = []
            self.interarrivals = xp.tolist()

            self.service_times = []
            self.service_times = yp.tolist()
            print(self.interarrivals)
            print(self.service_times)
            self.clock = 0.0

            self.next_arrival = self.interarrivals.pop(0)
            self.next_departure = float('inf')

            self.num_in_queue = 0
            self.times_of_arrivalqueue = []  # store times of arrivals who are waiting in the queue
            self.service_times_in_queue = []  # store service times of waiting customers in the queue

            self.total_delay = 0.0
            self.num_of_delays = 0.0
            self.area_under_q = 0.0
            self.area_under_b = 0.0
            self.number_of_customers_in_q = 0

            self.server_status = 0  # 0 for IDLE , 1 for BUSY
            self.last_event_time = 0.0  # we will need to store last event clock time

        def start(self):
            while self.num_of_delays <= 5:
                self.timing()

        def timing(self):
            global avg_lifo
            self.clock = min(self.next_arrival, self.next_departure)  # First set clock to minimum time of next event
            self.update_register()
            if self.next_arrival <= self.next_departure:
                self.arrival()
                print("Arrival at Clock:" + str(self.clock))

            else:
                self.departure()
                print("Departure at " + str(self.clock))

            print("Server Status:" + str(self.server_status))
            print("Times of arrivals in Queue: " + str(self.times_of_arrivalqueue))
            print("Service times in Queue: " + str(self.service_times_in_queue))
            print("Number of Delays: " + str(self.num_of_delays))
            print("Total Delay:" + str(self.total_delay))
            print("Next Arrival Time: " + str(self.next_arrival))
            print("Next Departure Time: " + str(self.next_departure))
            print("Expected average Delay:" + str(self.total_delay / 6))
            avg_lifo = self.total_delay / 6
            self.number_of_customers_in_q = len(self.service_times_in_queue) + self.number_of_customers_in_q
            print("Average number of customers in queue:" + str(self.number_of_customers_in_q / 6))

            print(" ")

        def arrival(self):
            # Schedule next arrival , new_arrival = previous_arrival + inter_arrival time of next customer
            self.next_arrival += self.interarrivals.pop(0)

            if self.server_status == 0:  # server is idle
                self.server_status = 1  # make server BUSY
                delay = 0.0  # so delay is zero
                self.total_delay += delay
                self.num_of_delays += 1  # increase the number of customers delayed

                # schedule next departure, pop the first element of service_times list to get service time of this customer
                self.next_departure = self.clock + self.service_times.pop(0)

            else:  # Server is BUSY
                # increase queue length, this customer will have to wait in the queue
                self.num_in_queue += 1

                # store the arrival time and service time of this customer in seperate lists
                self.times_of_arrivalqueue.append(self.clock)
                self.service_times_in_queue.append(self.service_times.pop(0))

        def departure(self):
            # check number of customers in the queue
            if self.num_in_queue == 0:  # if no customer in the queue
                # make server IDLE
                self.server_status = 0
                # schedule next departure= infinity
                self.next_departure = float('infinity')

            else:
                # if queue not empty, pop one customer, decrease queue length
                self.num_in_queue -= 1
                self.num_of_delays += 1
                # AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
                # For SJF, finf the index of minimum service time from  service_times_in_queue list.
                # Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.

                last_ind = len(self.times_of_arrivalqueue)

                arrival = self.times_of_arrivalqueue.pop(last_ind - 1)

                last_ind_q = len(self.service_times_in_queue)

                delay = self.clock - arrival
                self.total_delay += delay
                self.next_departure = self.clock + self.service_times_in_queue.pop(last_ind_q - 1)

        def update_register(self):
            time_differnce = self.clock - self.last_event_time
            self.area_under_q += self.num_in_queue * time_differnce
            self.area_under_b += self.server_status * time_differnce
            self.last_event_time = self.clock

    s = Simulation()
    s.start()


def sjf(xp, yp):
    import numpy as np
    np.random.seed(0)

    class Simulation:

        def __init__(self):
            self.interarrivals = []
            self.interarrivals = xp.tolist()

            self.service_times = []
            self.service_times = yp.tolist()
            print(self.interarrivals)
            print(self.service_times)
            self.clock = 0.0

            self.next_arrival = self.interarrivals.pop(0)
            self.next_departure = float('inf')

            self.num_in_queue = 0
            self.times_of_arrivalqueue = []  # store times of arrivals who are waiting in the queue
            self.service_times_in_queue = []  # store service times of waiting customers in the queue

            self.total_delay = 0.0
            self.num_of_delays = 0.0
            self.area_under_q = 0.0
            self.area_under_b = 0.0
            self.number_of_customers_in_q = 0.0

            self.server_status = 0  # 0 for IDLE , 1 for BUSY
            self.last_event_time = 0.0  # we will need to store last event clock time

        def start(self):
            while self.num_of_delays <= 5:
                self.timing()

        def timing(self):
            global avg_sjf
            self.clock = min(self.next_arrival, self.next_departure)  # First set clock to minimum time of next event
            self.update_register()
            if self.next_arrival <= self.next_departure:
                self.arrival()
                print("Arrival at Clock:" + str(self.clock))

            else:
                self.departure()
                print("Departure at " + str(self.clock))

            print("Server Status:" + str(self.server_status))
            print("Times of arrivals in Queue: " + str(self.times_of_arrivalqueue))
            print("Service times in Queue: " + str(self.service_times_in_queue))
            print("Number of Delays: " + str(self.num_of_delays))
            print("Total Delay:" + str(self.total_delay))
            print("Next Arrival Time: " + str(self.next_arrival))
            print("Next Departure Time: " + str(self.next_departure))
            print("Expected average Delay:" + str(self.total_delay / 6))
            avg_sjf = self.total_delay / 6
            self.number_of_customers_in_q = len(self.service_times_in_queue) + self.number_of_customers_in_q
            print("Average number of customers in queue:" + str(self.number_of_customers_in_q / 6))
            print(" ")

        def arrival(self):
            # Schedule next arrival , new_arrival = previous_arrival + inter_arrival time of next customer
            self.next_arrival += self.interarrivals.pop(0)

            if self.server_status == 0:  # server is idle
                self.server_status = 1  # make server BUSY
                delay = 0.0  # so delay is zero
                self.total_delay += delay
                self.num_of_delays += 1  # increase the number of customers delayed

                # schedule next departure, pop the first element of service_times list to get service time of this customer
                self.next_departure = self.clock + self.service_times.pop(0)

            else:  # Server is BUSY
                # increase queue length, this customer will have to wait in the queue
                self.num_in_queue += 1

                # store the arrival time and service time of this customer in seperate lists
                self.times_of_arrivalqueue.append(self.clock)
                self.service_times_in_queue.append(self.service_times.pop(0))

        def departure(self):

            # check number of customers in the queue
            if self.num_in_queue == 0:  # if no customer in the queue
                # make server IDLE
                self.server_status = 0
                # schedule next departure= infinity
                self.next_departure = float('infinity')

            else:
                # if queue not empty, pop one customer, decrease queue length
                self.num_in_queue -= 1
                self.num_of_delays += 1
                # AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
                # For SJF, finf the index of minimum service time from  service_times_in_queue list.
                # Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.

                index, value = min(enumerate(self.service_times_in_queue), key=operator.itemgetter(1))

                arrival = self.times_of_arrivalqueue.pop(index)

                last_ind_q = len(self.service_times_in_queue)

                delay = self.clock - arrival
                self.total_delay += delay
                self.next_departure = self.clock + self.service_times_in_queue.pop(index)

        def update_register(self):
            time_differnce = self.clock - self.last_event_time
            self.area_under_q += self.num_in_queue * time_differnce
            self.area_under_b += self.server_status * time_differnce
            self.last_event_time = self.clock

    s = Simulation()
    s.start()


x = 0
np.random.seed(0)
a = np.random.exponential(1/3, size = 20)
d = np.random.exponential(1/4, size = 20)
if x == 0:
    fifo(a, d)
    print("Utilization: " + str((0.2 / 0.3) * 100), "%")
    print(" ")
    print(" ")
    print("LIFO")
    lifo(a, d)
    print("Utilization: " + str((0.2 / 0.3) * 100), "%")
    print(" ")
    print(" ")

    print("SJF")
    sjf(a, d)
    print("Utilization: " + str((0.2 / 0.3) * 100), "%")
bn = min(avg_lifo, avg_sjf, avg_fifo)
if avg_lifo == bn:
    print("FIFO is better ")
if avg_fifo == bn:
    print("LIFO is better ")
if avg_sjf == bn:
    print("SJF is better ")